#!/usr/bin/env python

###
### mapSamples: Script to map individual sample data onto a network, yeilding a sample-specific
### network
###
### Authors:
###
###		Evan Paull (epaull@soe.ucsc.edu)
###
###
### Minimum Data Inputs: 
###		
###		- sample_matrix: a gene expression matrix with normalized, median centered values per sample (column), with
###		gene names on the rows. Typically the values should be centered by the expression of a group of normal-adjacent 
###		samples.
###		- a search pathway in .sif format (geneA <interaction> geneB). Most likely a TieDIE global solution network
###
###

import os, sys, re
from optparse import OptionParser
import numpy as np
from collections import defaultdict
parser = OptionParser()
parser.add_option("-s","--sample_events",dest="events",action="store",default=None,help="VIPER scores for phospho regulators")
parser.add_option("-t","--sample_activity",dest="activities",action="store",default=None,help="VIPER scores for expression regulators")
parser.add_option("-x","--sample_phos_data",dest="phos_data",action="store",default=None,help="Phospho Matrix for Samples")
parser.add_option("-m","--map",dest="map",action="store",default=None,help="Mapping from phosphorylated proteins to real for siginificant D.E. proteins")
parser.add_option("-b","--peptide_gene_map",dest="peptide_gene_map",action="store",default=None,help="Mapping from phosphorylated proteins to genes for everything")
parser.add_option("-n","--network",dest="network",action="store",default=None,help="Full network .sif file for inferring TF regulons")
parser.add_option("-o","--output",dest="output",action="store",default=None,help="Full network .sif file for inferring TF regulons")
(opts, args) = parser.parse_args()

sys.path.append(os.path.dirname(sys.argv[0])+'/../../../lib')
from tiedie_util import *

from collections import defaultdict
from pathway import Pathway, NodeConsistencyValidator 

def parseFullNet(file):
	network = {}
	# map genes to peptides
	map = {}
	for line in open(file, 'r'):
		parts = line.rstrip().split('\t')
		a, b, phos, score, sign, functional, interaction = parts
		peptideA, peptideB = phos.split(':')
		# encode correlation as activating/inactivating edge type
		if sign == "+":
			interaction = "-a>"
		elif sign == "-":
			interaction = "-a|"
		if peptideA not in network:
			network[peptideA] = set()
		network[peptideA].add((interaction, peptideB))

		if a not in map:
			map[a] = set()
		map[a].add(peptideA)
		if b not in map:
			map[b] = set()
		map[b].add(peptideB)
		
	return (network, map)

events = parseMatrix(opts.events, None, 1.5)
activities = parseMatrix(opts.activities, None, 1.5)
phos_peptide_scores = parseMatrix(opts.phos_data, None, 0.0) 

network, gene_to_peptides_map = parseFullNet(opts.network)
peptides_to_genes = {}
for gene in gene_to_peptides_map:
	for peptide in gene_to_peptides_map[gene]:
		peptides_to_genes[peptide] = gene
# use the probespace network, and include node level scores

sig_de_peptides_map = {}
for line in open(opts.map, 'r'):
	gene, prot = line.rstrip().split('\t')
	sig_de_peptides_map[prot] = gene


test_samples = set(events.keys()).intersection(activities.keys())

all_edges = defaultdict(float)
sample_networks = {}

for sample in test_samples:

	sample_networks[sample] = set()
	print sample+'\tevents\t:'+','.join(events[sample])
	print sample+'\tactivities\t:'+','.join(activities[sample])

	# get upstream nodes
	upstream_nodes = set()
	upstream_nodes = upstream_nodes.union(set(events[sample].keys()))
	downstream_nodes = activities[sample].keys()
	# convert to peptides for the graph
	upstream_peptides = set()
	downstream_peptides = set()
	for gene in upstream_nodes:
		if gene not in gene_to_peptides_map:
			continue
		upstream_peptides = upstream_peptides.union(gene_to_peptides_map[gene])
	for gene in downstream_nodes:
		if gene not in gene_to_peptides_map:
			continue
		downstream_peptides = downstream_peptides.union(gene_to_peptides_map[gene])

	peptide_score_vector = {}
	for peptide in phos_peptide_scores[sample]:
		peptide_score_vector[peptide] = phos_peptide_scores[sample][peptide]

	for peptide in sig_de_peptides_map:
		gene = sig_de_peptides_map[peptide]
		# does this sample have a score over this value? 
		if peptide in phos_peptide_scores[sample] and float(phos_peptide_scores[sample][peptide]) > 1.5:
			upstream_nodes.add(gene)


	validator = NodeConsistencyValidator(peptide_score_vector)
	pathway = Pathway(network, validator=validator, opts={'undirected_edges':set(['-a>', '-a|'])})

	edges = pathway.allPaths(upstream_peptides, downstream_peptides, 3)
	for edge in edges:
		gene_edge = (peptides_to_genes[edge[0]], edge[1], peptides_to_genes[edge[2]])
		all_edges[gene_edge] += 1.0
		sample_networks[sample].add(gene_edge)


fh = open(opts.output+'/overall_network.txt', 'w')
samples = ['WA14', 'WA30', 'WA40', 'WA53', 'WA55']
fh.write('\t'.join(['source', 'interaction', 'target', 'count'])+'\t'+'\t'.join(samples)+'\n')
for edge in all_edges:
	sample_str = ""
	for sample in samples:
		if edge in sample_networks[sample]:
			sample_str += '\t1'
		else:
			sample_str += '\t0'
	fh.write('\t'.join([edge[0], edge[1], edge[2], str(all_edges[edge])])+sample_str+'\n')
fh.close()

for sample in test_samples:

	fh = open(opts.output+'/'+sample+'.txt', 'w')

	fh.write('\t'.join(['source', 'interaction', 'target', 'active'])+'\n')

	for edge in all_edges:
		if edge in sample_networks[sample]:
			is_active = "1"
		else:
			is_active = "0"

		# active only if in this network
		fh.write('\t'.join(edge)+'\t'+is_active+'\n')
	fh.close()

	# make activities file: name, Activity score
	
	fh = open(opts.output+'/'+sample+'.activities.txt', 'w')
	fh.write('name\tActivity\tKinase\n')
	scores = {}
	for gene in activities[sample]:
		scores[gene] = activities[sample][gene]
	for gene in events[sample]:
		scores[gene] = events[sample][gene]
	for gene in scores:
		if gene in events[sample]:
			fh.write(gene+'\t'+str(scores[gene])+'\t1\n')
		else:
			fh.write(gene+'\t'+str(scores[gene])+'\t0\n')
	fh.close()

