#!/usr/bin/env python

# stand-alone implementation of the master regulator analysis used in TieDIE. 

import sys, os
import math
from optparse import OptionParser
parser = OptionParser()
# data specific for patient-specific networks here
parser.add_option("-n","--network",dest="network",action="store",
		default=None,help=".sif network file for the curated pathway to search."
		" Each line should have format "
		"'<source> <(-a>,-a|,-t>,-t|,-component>)> <target>'")
parser.add_option("-e", "--d_expr",dest="d_expr",action="store",default=None,
		type="string",help="List of significantly differentially expressed "
		"genes, along with log-FC or FC values (i.e. by edgeR for RNA-Seq or "
		"SAM for microarray data. Generated by a sample-dichotomy of interest")
parser.add_option("-v","--verbose",dest="verbose",action="store_true",default=False)
parser.add_option("-s","--step",dest="step",action="store",default=50, type=int)
parser.add_option("-m","--max_nodes",dest="max_nodes",action="store",default=1000, type=int)
parser.add_option("-o","--output",dest="output",action="store",default="cutgraph_Result")
parser.add_option("--range",dest="range",action="store",default="3:None")
parser.add_option("--simple",dest="simple",action="store",default=None, help="Set the number of nodes to be X fraction of the input set size (classic TieDIE, without considering input genes)")
parser.add_option("-d","--sample_data",dest="sample_data",action="store",default=None)
#parser.add_option("-p","--permutations",dest="permutations",action="store",default=1000, help=
#		"Number of permutations to use when generating the empirical p-value")
(opts, args) = parser.parse_args()
	
from tiedie_util import *
from cutgraph import cutGraph 

def intersectNodes(network_nodes, data):

	cleaned_data = {}
	for sample in data:
		cleaned_data[sample] = {}
		for gene in data[sample]:
			if gene not in network_nodes:
				continue
			cleaned_data[sample][gene] = data[sample][gene]

	return cleaned_data

def parseEvents(file, tf_cutoff=1.5):

	events = {}
	activities = {}

	fh = open(file, 'r')
	header = False
	for line in fh:
		parts = line.rstrip().split("\t")
		if not header:
			header = parts
			for i in range(2,len(parts)):
				events[header[i]] = {}
				activities[header[i]] = {}
			continue

		gene = parts[0]
		type = parts[1]
		for i in range(2,len(parts)):
			if parts[1] == "Genomic_Event":	
				#if float(parts[i]) > 1.5:
				if abs(float(parts[i])) > 0.0:
					events[header[i]][gene] = float(parts[i])
			if parts[1] == "TF_Activity":	
				if abs(float(parts[i])) > tf_cutoff:
					activities[header[i]][gene] = float(parts[i])

	fh.close()
	return (events, activities)


sys.stderr.write("Parsing Network File..\n")
network = None
if opts.network.endswith(".sif"):	
	network = parseNet(opts.network)

nodes = set()
directed_edges = {}
for s in network:
	nodes.add(s)
	for (i,t) in network[s]:
		nodes.add(t)
		directed_edges[(s,t)] = i

# hash with samples, then by gene
# columns are samples, rows are genes
scores_by_sample = parseMatrix(opts.d_expr, transpose=True)

# 
sample_events, sample_activities = parseEvents(opts.sample_data, 1.5)

# create an undirected graph
graph = cutGraph(network, False, opts.verbose, opts.max_nodes, opts.step)
if not os.path.exists(opts.output):
	os.mkdir(opts.output)

scores_by_sample = intersectNodes(nodes, scores_by_sample)
min_subnetSize, max_subnetSize = [v for v in opts.range.split(":")]
min_subnetSize = int(min_subnetSize)
for sample in sorted(scores_by_sample.keys()):
	print "finding network for sample:"+str(sample)
	# look at the top 100 genes
	#subgraphs = graph.getSubgraphs(100)
	#print subgraphs.edges()
	# find the input set size:
	events = set(sample_events[sample].keys())
	act = set(sample_activities[sample].keys())
	full_input_set = events.union(act)
	print "Input set size:"+str(len(full_input_set))
	graph.setScores(scores_by_sample[sample], full_input_set)
	threshold = None
	g = None
	if not opts.simple:
		threshold, g = graph.kSubnetsSearch(min_subnetSize, max_subnetSize)
	else:
		size_factor = int(math.floor(float(opts.simple)*len(full_input_set)))
		g = graph.getSubgraphs(graph.G, size_factor)

	graph_fh = open(opts.output+"/"+sample+".sif", 'w')
	for edge in g.edges():
		edge_type = g.get_edge_data(edge[0], edge[1])['i']

		# HACK to fix directionality problem
		if edge not in directed_edges:
			graph_fh.write('\t'.join([edge[1], edge_type, edge[0]])+'\n')
		else:
			graph_fh.write('\t'.join([edge[0], edge_type, edge[1]])+'\n')
				
	graph_fh.close()	
	
