#!/usr/bin/env python

# 
# Parse the PSN network outputs--both network files and source/target information. 
# 
# - Generate networks for each patient that connect source and target nodes. 
# - Node color files are the concensus network heats 
#

import os, sys
from collections import defaultdict
from optparse import OptionParser
parser = OptionParser()
parser.add_option("-n","--networks_dir",dest="networks_dir",action="store",default=None,help="Networks in .sif format")
parser.add_option("-c","--concensus",dest="concensus",action="store",default=None,help="Concensus inclusion network file")
parser.add_option("-d","--sample_data",dest="sample_data",action="store",default=None)
parser.add_option("--undirected_types",dest="undirected_types",action="store",default=None)
parser.add_option("--output",dest="output",action="store",default=None)
parser.add_option("-x","--depth",dest="depth",action="store",default=3)
(opts, args) = parser.parse_args()

from tiedie_util import *
from pathway import Pathway, BasicPathValidator, SHERPAValidator, TriplesValidator


def parseSCORES(file):

	scores = {}
	fh = open(file, 'r')
	for line in fh:
		gene, score = line.rstrip().split("\t")
		scores[gene] = float(score)

	return scores

def parseEvents(file, tf_cutoff=1.5):

	events = {}
	activities = {}

	fh = open(file, 'r')
	header = False
	for line in fh:
		parts = line.rstrip().split("\t")
		if not header:
			header = parts
			for i in range(2,len(parts)):
				events[header[i]] = {}
				activities[header[i]] = {}
			continue

		gene = parts[0]
		type = parts[1]
		for i in range(2,len(parts)):
			if parts[1] == "Genomic_Event":	
				#if float(parts[i]) > 1.5:
				if abs(float(parts[i])) > 0.0:
					events[header[i]][gene] = float(parts[i])
			if parts[1] == "TF_Activity":	
				if abs(float(parts[i])) > tf_cutoff:
					activities[header[i]][gene] = float(parts[i])

	fh.close()
	return (events, activities)

def getSigns(scores):

	signs = {}

	for node in scores:
		if scores[node] > 0:
			signs[node] = '+'
		elif scores[node] < 0:
			signs[node] = '-'

	return signs

undirected_types = set(opts.undirected_types.split(':'))
# get concensus tiedie scores
if opts.concensus:
	tiedie_c = parseSCORES(opts.concensus)
sample_events, sample_activities = parseEvents(opts.sample_data, 1.5)

sys.path.append(os.path.dirname(sys.argv[0])+'/../lib')
from tiedie_util import *

# create output directory
output = opts.output
os.mkdir(output)

all_edges = set()
sample_networks = {}
# listdirectory, 
for file in os.listdir(opts.networks_dir):
	if not file.endswith('.sif'):
		continue
	sample_id = file.rstrip('.sif')	

	events = sample_events[sample_id]
	event_signs = getSigns(events)
	activities = sample_activities[sample_id]
	act_signs = getSigns(activities)

	validator = BasicPathValidator({'source':events.keys(), 'target':activities.keys()})

	print "Finding network for sample: "+sample_id
	pathway = Pathway(validator=validator, opts={'undirected_edges':undirected_types, 'directed':True})
	pathway.parseNet(opts.networks_dir+'/'+file)
	filtered_edges = pathway.allPathEdges(events, activities, int(opts.depth))
	all_edges = set(filtered_edges).union(set(all_edges))
	sample_networks[sample_id] = filtered_edges
	print "number of edges for sample:"+str(len(filtered_edges))
	out = open(output+'/'+sample_id+'.txt', 'w')
	out.write("source\tinteraction\ttarget\n")
	for edge in sample_networks[sample_id]:
		out.write("\t".join(edge)+"\n")
	out.close()


print "Number of total edges:"+str(len(all_edges))
# now get the union of all filtered networks, do shading for each. Print out an edge-weight 
# text file for each samle that has shading included for edges that are present. 
# networks that are already based on the posterior of the concensus are there. 
#for sample in sample_networks:
#		file = output+'/'+sample+'.txt'	
#		out = open(file, 'w')
#		out.write("source\tinteraction\ttarget\tactive\n")
#		for edge in all_edges:
#			if edge not in reference_edges:
#				continue
#			if edge in sample_networks[sample]:
#				out.write("\t".join(edge)+"\t1"+"\n")
#			else:
#				out.write("\t".join(edge)+"\t0"+"\n")
#		out.close()
					
## print summary files for each sample
all_genes = set()
for edge in all_edges:
	all_genes.add(edge[0])	
	all_genes.add(edge[2])	

for sample_id in sample_networks:
		
	events = sample_events[sample_id]
	event_signs = getSigns(events)
	activities = sample_activities[sample_id]
	act_signs = getSigns(activities)

	out = open(output+'/'+sample_id+'.activities.txt', 'w')
	out.write("name\tActivity\n")
	for gene in all_genes:
		if gene in events:
			out.write(gene+"\t"+str(events[gene])+'\n')
		elif gene in activities:
			out.write(gene+"\t"+str(activities[gene])+'\n')
		else:
			out.write(gene+"\t"+str(0)+'\n')
	out.close()

